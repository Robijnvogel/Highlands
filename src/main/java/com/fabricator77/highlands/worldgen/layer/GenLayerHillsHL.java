package com.fabricator77.highlands.worldgen.layer;

import fabricator77.multiworld.api.biomeregistry.AdvancedBiomeRegistry;
import com.fabricator77.highlands.api.HighlandsBiomes;
import net.minecraft.util.WeightedRandom;
import net.minecraft.world.gen.layer.GenLayer;
import net.minecraft.world.gen.layer.IntCache;
import net.minecraftforge.common.BiomeManager.BiomeEntry;

public class GenLayerHillsHL extends GenLayer {

    private GenLayer river;
    private BiomeEntry[] islandBiomes;
    private BiomeEntry[] oceanBiomes;

    public GenLayerHillsHL(long par1, GenLayer par3, GenLayer par4) {
        super(par1);
        this.parent = par3;
        this.river = par4;
        islandBiomes = AdvancedBiomeRegistry.getBiomesOfType("island");
        oceanBiomes = AdvancedBiomeRegistry.getBiomesOfType("ocean");
    }

    /**
     * Returns a list of integer values generated by this layer. These may be
     * interpreted as temperatures, rainfall amounts, or biomeList[] indices
     * based on the particular GenLayer subclass.
     */
    @Override
    public int[] getInts(int par1, int par2, int par3, int par4) {
        int[] aint = this.parent.getInts(par1 - 1, par2 - 1, par3 + 2, par4 + 2);
        int[] aint1 = this.river.getInts(par1 - 1, par2 - 1, par3 + 2, par4 + 2);
        int[] aint2 = IntCache.getIntCache(par3 * par4);

        for (int i1 = 0; i1 < par4; ++i1) {
            for (int j1 = 0; j1 < par3; ++j1) {
                // loop start
                this.initChunkSeed((long) (j1 + par1), (long) (i1 + par2));
                int k1 = aint[j1 + 1 + (i1 + 1) * (par3 + 2)];  // parent layer
                int l1 = aint1[j1 + 1 + (i1 + 1) * (par3 + 2)]; // river layer
                boolean flag = (l1 - 2) % 29 == 0; // is biomeID 31 (megaTaiga biome)

                //BiomeGenBase biome2 = BiomeGenBase.getBiomeGenArray()[aint1[j1 + i1 * par3]];
                //Logs.log(Level.INFO, "[Highlands] GenLayerRareBiomeHL input=" + biome2.biomeName);
                if (k1 > 255) {
                    //Logs.log(Level.INFO, "[Highlands] GenLayerRareBiomeHL k1=" + k1);
                    // k1 = 0;
                }

                if (suitableForSubBiome(k1, l1)) {
                    //if (k1 != 0 && l1 >= 2 && l1 == 32 && k1 < 128) {//TODO remove vanilla hardcoded biome ids/assumptions
                    if (AdvancedBiomeRegistry.biomeEntries[k1].subBiomes.length > 0) {
                        aint2[j1 + i1 * par3] = getWeightedBiomeIDFromType(AdvancedBiomeRegistry.biomeEntries[k1].subBiomes);
                        //Logs.log(Level.INFO, "placing sub-biome "+BiomeGenBase.getBiome(aint2[j1 + i1 * par3]).biomeName);
                        //aint2[j1 + i1 * par3] = AdvancedBiomeRegistry.biomeEntries[k1].subBiomes[0].biome.biomeID;
                    } else {
                        aint2[j1 + i1 * par3] = k1;
                    }
                } else if (this.nextInt(3) != 0 && !flag) // 2 in 3 chance + not megaTaiga
                {
                    aint2[j1 + i1 * par3] = k1;
                } else {
                    int i2 = k1;
                    int j2;

                    if (AdvancedBiomeRegistry.biomeEntries[k1].hillsBiomes.length > 0) {
                        i2 = getWeightedBiomeIDFromType(AdvancedBiomeRegistry.biomeEntries[k1].hillsBiomes);
                        // Logs.log(Level.INFO, "placing hills-biome "+BiomeGenBase.getBiome(i2).biomeName);
                        //i2 = AdvancedBiomeRegistry.biomeEntries[k1].hillsBiomes[0].biome.biomeID;
                        flag = false;
                    } // supports multiple ocean and island biomes
                    else if (isOceanEdge(aint, j1, i1, par3) && this.nextInt(4) == 0) // was 3
                    {
                        //islands
                        i2 = getWeightedBiomeIDFromType(islandBiomes);

                        flag = false; //crash fix ?
                    }

                    if (flag && i2 != k1) {
                        if (AdvancedBiomeRegistry.biomeEntries[k1].subBiomes.length > 0) {
                            i2 = getWeightedBiomeIDFromType(AdvancedBiomeRegistry.biomeEntries[k1].subBiomes);
                            //Logs.log(Level.INFO, "placing sub-biome "+BiomeGenBase.getBiome(i2).biomeName);
                            // i2 = AdvancedBiomeRegistry.biomeEntries[k1].subBiomes[0].biome.biomeID;
                        } else {
                            i2 = k1;
                        }
                    }

                    // set output
                    if (i2 == k1) // if subbiome was already here, then leave it.
                    {
                        aint2[j1 + i1 * par3] = k1;
                    } else {
                        j2 = aint[j1 + 1 + (i1 + 1 - 1) * (par3 + 2)];
                        int k2 = aint[j1 + 1 + 1 + (i1 + 1) * (par3 + 2)];
                        int l2 = aint[j1 + 1 - 1 + (i1 + 1) * (par3 + 2)];
                        int i3 = aint[j1 + 1 + (i1 + 1 + 1) * (par3 + 2)];
                        int j3 = 0;

                        if (suitableForSubBiome(j2, k1)) {
                            ++j3;
                        }

                        if (suitableForSubBiome(k2, k1)) {
                            ++j3;
                        }

                        if (suitableForSubBiome(l2, k1)) {
                            ++j3;
                        }

                        if (suitableForSubBiome(i3, k1)) {
                            ++j3;
                        }

                        if (j3 >= 3) // create subbiomes only where surrounding biomes are same parent
                        // which means sub biomes cannot be on edges
                        {
                            aint2[j1 + i1 * par3] = i2;
                        } else {
                            aint2[j1 + i1 * par3] = k1;
                        }
                    }
                }
                // loop end
            }
        }

        return aint2;
    }

    private boolean isHLOcean(int biomeID) {
        if (HighlandsBiomes.ocean2 != null) {
            return biomeID == HighlandsBiomes.ocean2.biomeID;
        }
        return false;
    }

    private int getWeightedBiomeIDFromType(BiomeEntry[] biomeType) {
        int total = (int) this.nextLong(WeightedRandom.getTotalWeight(biomeType));
        BiomeEntry biomeEntry = (BiomeEntry) WeightedRandom.getItem(biomeType, total);
        return biomeEntry.biome.biomeID;
    }

    private boolean isOceanEdge(int[] aint, int j1, int i1, int par3) {
        // center biome
        int k1 = aint[j1 + 1 + (i1 + 1) * (par3 + 2)];
        // adjacent biomes
        int a1 = aint[j1 + 1 + (i1 + 1 - 1) * (par3 + 2)];
        int a2 = aint[j1 + 1 + 1 + (i1 + 1) * (par3 + 2)];
        int a3 = aint[j1 + 1 - 1 + (i1 + 1) * (par3 + 2)];
        int a4 = aint[j1 + 1 + (i1 + 1 + 1) * (par3 + 2)];
        // count valid matches with center

        int count = 0;
        if (AdvancedBiomeRegistry.biomeEntries[a1] != null && AdvancedBiomeRegistry.biomeEntries[a1].type == "ocean") {
            ++count;
        }

        if (AdvancedBiomeRegistry.biomeEntries[a2] != null && AdvancedBiomeRegistry.biomeEntries[a2].type == "ocean") {
            ++count;
        }

        if (AdvancedBiomeRegistry.biomeEntries[a3] != null && AdvancedBiomeRegistry.biomeEntries[a3].type == "ocean") {
            ++count;
        }

        if (AdvancedBiomeRegistry.biomeEntries[a4] != null && AdvancedBiomeRegistry.biomeEntries[a4].type == "ocean") {
            ++count;
        }

        if (count == 4) {
            return true;
        }

        return false;
    }

    private boolean suitableForSubBiome(int k1, int l1) {
        // parent not ocean &&
        // river not plains or ocean &&
        // river is megaTaiga
        // parent not sub biome
        // sub-biomes go here

        // l1 calculations
        // 282347 -2 %29
        // = 282345 %29
        // = 1
        // However problems exist with vanilla Jungle Hills/Edges biomes
        // due to ID numbers matching
        if (!isOcean(k1) && l1 >= 2 && (l1 - 2) % 29 == 1) {
            return true;
        }
        return false;
    }

    private boolean isOcean(int id) {
        for (int i = 0; i < oceanBiomes.length; i++) {
            if (oceanBiomes[i].biome.biomeID == id) {
                return true;
            }
        }
        return false;
    }

    private boolean isSubBiome(int id) {
        if (AdvancedBiomeRegistry.biomeEntries[id].type == "sub") {
            return true;
        }
        return false;
    }
}
